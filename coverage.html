
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>mcp: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">manticore-mcp-server/mcp/registry.go (74.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package mcp

import (
        "context"
        "encoding/json"
        "fmt"
        "log/slog"

        "manticore-mcp-server/config"
        "manticore-mcp-server/tools"
        "manticore-mcp-server/tools/search"
        "manticore-mcp-server/tools/tables"
        "manticore-mcp-server/tools/documents"
        "manticore-mcp-server/tools/clusters"

        mcp_golang "github.com/metoro-io/mcp-golang"
)

// Response represents unified response format for all MCP tools
type Response struct {
        Success bool        `json:"success"`
        Data    interface{} `json:"data,omitempty"`
        Error   string      `json:"error,omitempty"`
        Meta    *Meta       `json:"meta,omitempty"`
}

// Meta contains metadata about the response
type Meta struct {
        Total     int    `json:"total"`
        Count     int    `json:"count"`
        Limit     int    `json:"limit,omitempty"`
        Offset    int    `json:"offset,omitempty"`
        Table     string `json:"table,omitempty"`
        Cluster   string `json:"cluster,omitempty"`
        Operation string `json:"operation,omitempty"`
}

// Registry handles MCP tool registration
type Registry struct {
        tools  *tools.Handler
        config *config.Config
        logger *slog.Logger
}

// NewRegistry creates a new MCP tool registry
func NewRegistry(toolsHandler *tools.Handler, cfg *config.Config, logger *slog.Logger) *Registry <span class="cov8" title="1">{
        return &amp;Registry{
                tools:  toolsHandler,
                config: cfg,
                logger: logger,
        }
}</span>

// RegisterAll registers all Manticore tools with MCP server
func (r *Registry) RegisterAll(server *mcp_golang.Server) error <span class="cov0" title="0">{
        r.logger.Info("Registering all Manticore tools with MCP...")

        // Register search tools
        if err := r.registerSearchTools(server); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register search tools: %w", err)
        }</span>

        // Register table management tools
        <span class="cov0" title="0">if err := r.registerTableTools(server); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register table tools: %w", err)
        }</span>

        // Register document operation tools
        <span class="cov0" title="0">if err := r.registerDocumentTools(server); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register document tools: %w", err)
        }</span>

        // Register cluster tools
        <span class="cov0" title="0">if err := r.registerClusterTools(server); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to register cluster tools: %w", err)
        }</span>

        <span class="cov0" title="0">r.logger.Info("All Manticore tools registered successfully")
        return nil</span>
}

// registerSearchTools registers search-related tools
func (r *Registry) registerSearchTools(server *mcp_golang.Server) error <span class="cov0" title="0">{
        // Search tool
        err := server.RegisterTool("search", "Perform full-text search in Manticore index with advanced options",
                func(args map[string]interface{}) (*mcp_golang.ToolResponse, error) </span><span class="cov0" title="0">{
                        return r.handleSearchTool(args)
                }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r.logger.Debug("Search tools registered")
        return nil</span>
}

// registerTableTools registers table management tools
func (r *Registry) registerTableTools(server *mcp_golang.Server) error <span class="cov0" title="0">{
        // Show tables tool
        err := server.RegisterTool("show_tables", "List all tables/indexes in Manticore",
                func(args map[string]interface{}) (*mcp_golang.ToolResponse, error) </span><span class="cov0" title="0">{
                        return r.handleShowTablesTool(args)
                }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Describe table tool
        <span class="cov0" title="0">err = server.RegisterTool("describe_table", "Get detailed information about table schema",
                func(args map[string]interface{}) (*mcp_golang.ToolResponse, error) </span><span class="cov0" title="0">{
                        return r.handleDescribeTableTool(args)
                }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r.logger.Debug("Table management tools registered")
        return nil</span>
}

// registerDocumentTools registers document operation tools
func (r *Registry) registerDocumentTools(server *mcp_golang.Server) error <span class="cov0" title="0">{
        // Insert document tool
        err := server.RegisterTool("insert_document", "Insert a new document into Manticore index",
                func(args map[string]interface{}) (*mcp_golang.ToolResponse, error) </span><span class="cov0" title="0">{
                        return r.handleInsertDocumentTool(args)
                }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r.logger.Debug("Document operation tools registered")
        return nil</span>
}

// registerClusterTools registers cluster management tools
func (r *Registry) registerClusterTools(server *mcp_golang.Server) error <span class="cov0" title="0">{
        // Show cluster status tool
        err := server.RegisterTool("show_cluster_status", "Show status of cluster nodes",
                func(args map[string]interface{}) (*mcp_golang.ToolResponse, error) </span><span class="cov0" title="0">{
                        return r.handleClusterStatusTool(args)
                }</span>)
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">r.logger.Debug("Cluster tools registered")
        return nil</span>
}

// handleSearchTool processes search requests
func (r *Registry) handleSearchTool(args map[string]interface{}) (*mcp_golang.ToolResponse, error) <span class="cov8" title="1">{
        // Convert map to search args struct
        searchArgs, err := r.mapToSearchArgs(args)
        if err != nil </span><span class="cov8" title="1">{
                return r.errorResponse(fmt.Sprintf("Invalid search arguments: %v", err))
        }</span>

        // Apply default limit from config
        <span class="cov8" title="1">if searchArgs.Limit &lt;= 0 </span><span class="cov0" title="0">{
                searchArgs.Limit = r.config.MaxResultsPerQuery
        }</span>

        // Execute search
        <span class="cov8" title="1">ctx := context.Background()
        results, err := r.tools.Search.Execute(ctx, *searchArgs)
        if err != nil </span><span class="cov0" title="0">{
                return r.errorResponse(fmt.Sprintf("Search failed: %v", err))
        }</span>

        // Create response
        <span class="cov8" title="1">response := &amp;Response{
                Success: true,
                Data:    results,
                Meta: &amp;Meta{
                        Total:     len(results),
                        Count:     len(results),
                        Limit:     searchArgs.Limit,
                        Offset:    searchArgs.Offset,
                        Table:     searchArgs.Table,
                        Cluster:   searchArgs.Cluster,
                        Operation: "search",
                },
        }

        return r.successResponse(response)</span>
}

// handleShowTablesTool processes show tables requests
func (r *Registry) handleShowTablesTool(args map[string]interface{}) (*mcp_golang.ToolResponse, error) <span class="cov8" title="1">{
        tablesArgs := tables.ShowTablesArgs{
                Pattern: r.getStringArg(args, "pattern"),
                Cluster: r.getStringArg(args, "cluster"),
        }

        ctx := context.Background()
        tables, err := r.tools.Tables.ShowTables(ctx, tablesArgs)
        if err != nil </span><span class="cov0" title="0">{
                return r.errorResponse(fmt.Sprintf("Failed to show tables: %v", err))
        }</span>

        <span class="cov8" title="1">response := &amp;Response{
                Success: true,
                Data:    tables,
                Meta: &amp;Meta{
                        Total:     len(tables),
                        Count:     len(tables),
                        Cluster:   tablesArgs.Cluster,
                        Operation: "show_tables",
                },
        }

        return r.successResponse(response)</span>
}

// handleDescribeTableTool processes describe table requests
func (r *Registry) handleDescribeTableTool(args map[string]interface{}) (*mcp_golang.ToolResponse, error) <span class="cov8" title="1">{
        table := r.getStringArg(args, "table")
        if table == "" </span><span class="cov8" title="1">{
                return r.errorResponse("Table parameter is required")
        }</span>

        <span class="cov8" title="1">describeArgs := tables.DescribeTableArgs{
                Table:   table,
                Cluster: r.getStringArg(args, "cluster"),
        }

        ctx := context.Background()
        schema, err := r.tools.Tables.DescribeTable(ctx, describeArgs)
        if err != nil </span><span class="cov8" title="1">{
                return r.errorResponse(fmt.Sprintf("Failed to describe table: %v", err))
        }</span>

        <span class="cov8" title="1">response := &amp;Response{
                Success: true,
                Data:    schema,
                Meta: &amp;Meta{
                        Table:     describeArgs.Table,
                        Cluster:   describeArgs.Cluster,
                        Operation: "describe_table",
                },
        }

        return r.successResponse(response)</span>
}

// handleInsertDocumentTool processes document insertion requests
func (r *Registry) handleInsertDocumentTool(args map[string]interface{}) (*mcp_golang.ToolResponse, error) <span class="cov8" title="1">{
        table := r.getStringArg(args, "table")
        if table == "" </span><span class="cov8" title="1">{
                return r.errorResponse("Table parameter is required")
        }</span>

        <span class="cov8" title="1">document, exists := args["document"]
        if !exists </span><span class="cov8" title="1">{
                return r.errorResponse("Document parameter is required")
        }</span>

        <span class="cov8" title="1">documentMap, ok := document.(map[string]interface{})
        if !ok </span><span class="cov8" title="1">{
                return r.errorResponse("Document must be a valid object")
        }</span>

        <span class="cov8" title="1">insertArgs := documents.InsertDocumentArgs{
                Table:    table,
                Cluster:  r.getStringArg(args, "cluster"),
                Document: documentMap,
                Replace:  r.getBoolArg(args, "replace"),
        }

        // Handle optional ID
        if idVal := r.getIntArg(args, "id"); idVal != 0 </span><span class="cov0" title="0">{
                id := int64(idVal)
                insertArgs.ID = &amp;id
        }</span>

        <span class="cov8" title="1">ctx := context.Background()
        result, err := r.tools.Documents.InsertDocument(ctx, insertArgs)
        if err != nil </span><span class="cov0" title="0">{
                return r.errorResponse(fmt.Sprintf("Failed to insert document: %v", err))
        }</span>

        <span class="cov8" title="1">response := &amp;Response{
                Success: true,
                Data:    result,
                Meta: &amp;Meta{
                        Table:     insertArgs.Table,
                        Cluster:   insertArgs.Cluster,
                        Operation: "insert_document",
                },
        }

        return r.successResponse(response)</span>
}

// handleClusterStatusTool processes cluster status requests
func (r *Registry) handleClusterStatusTool(args map[string]interface{}) (*mcp_golang.ToolResponse, error) <span class="cov8" title="1">{
        statusArgs := clusters.ShowClusterStatusArgs{
                Pattern: r.getStringArg(args, "pattern"),
        }

        ctx := context.Background()
        status, err := r.tools.Clusters.ShowClusterStatus(ctx, statusArgs)
        if err != nil </span><span class="cov0" title="0">{
                return r.errorResponse(fmt.Sprintf("Failed to get cluster status: %v", err))
        }</span>

        <span class="cov8" title="1">response := &amp;Response{
                Success: true,
                Data:    status,
                Meta: &amp;Meta{
                        Operation: "cluster_status",
                },
        }

        return r.successResponse(response)</span>
}

// Helper methods

func (r *Registry) successResponse(response *Response) (*mcp_golang.ToolResponse, error) <span class="cov8" title="1">{
        jsonData, err := json.MarshalIndent(response, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return r.errorResponse(fmt.Sprintf("Failed to serialize response: %v", err))
        }</span>

        <span class="cov8" title="1">return mcp_golang.NewToolResponse(
                mcp_golang.NewTextContent(string(jsonData)),
        ), nil</span>
}

func (r *Registry) errorResponse(message string) (*mcp_golang.ToolResponse, error) <span class="cov8" title="1">{
        response := &amp;Response{
                Success: false,
                Error:   message,
        }

        jsonData, _ := json.MarshalIndent(response, "", "  ")
        return mcp_golang.NewToolResponse(
                mcp_golang.NewTextContent(string(jsonData)),
        ), nil
}</span>

func (r *Registry) getStringArg(args map[string]interface{}, key string) string <span class="cov8" title="1">{
        if val, exists := args[key]; exists </span><span class="cov8" title="1">{
                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (r *Registry) getIntArg(args map[string]interface{}, key string) int <span class="cov8" title="1">{
        if val, exists := args[key]; exists </span><span class="cov8" title="1">{
                switch v := val.(type) </span>{
                case int:<span class="cov8" title="1">
                        return v</span>
                case float64:<span class="cov8" title="1">
                        return int(v)</span>
                }
        }
        <span class="cov8" title="1">return 0</span>
}

// mapToSearchArgs converts map arguments to search Args struct
func (r *Registry) mapToSearchArgs(args map[string]interface{}) (*search.Args, error) <span class="cov8" title="1">{
        searchArgs := &amp;search.Args{
                // Basic parameters
                Query:   r.getStringArg(args, "query"),
                Table:   r.getStringArg(args, "table"),
                Cluster: r.getStringArg(args, "cluster"),
                
                // Pagination
                Limit:  r.getIntArg(args, "limit"),
                Offset: r.getIntArg(args, "offset"),
                
                // Field selection
                Fields: r.getStringSliceArg(args, "fields"),
                
                // Search options
                Ranker:              r.getStringArg(args, "ranker"),
                MatchMode:           r.getStringArg(args, "match_mode"),
                MaxMatches:          r.getIntArg(args, "max_matches"),
                Cutoff:              r.getIntArg(args, "cutoff"),
                MaxQueryTime:        r.getIntArg(args, "max_query_time"),
                FieldWeights:        r.getStringIntMapArg(args, "field_weights"),
                NotTermsOnlyAllowed: r.getIntArg(args, "not_terms_only_allowed"),
                BooleanSimplify:     r.getIntArg(args, "boolean_simplify"),
                AccurateAggregation: r.getIntArg(args, "accurate_aggregation"),
                RandSeed:            r.getIntArg(args, "rand_seed"),
                Comment:             r.getStringArg(args, "comment"),
                AgentQueryTimeout:   r.getIntArg(args, "agent_query_timeout"),
                RetryCount:          r.getIntArg(args, "retry_count"),
                RetryDelay:          r.getIntArg(args, "retry_delay"),
                Morphology:          r.getStringArg(args, "morphology"),
                TokenFilter:         r.getStringArg(args, "token_filter"),
                MaxPredictedTime:    r.getIntArg(args, "max_predicted_time"),
                
                // Ordering
                OrderBy:   r.getStringSliceArg(args, "order_by"),
                GroupBy:   r.getStringSliceArg(args, "group_by"),
                GroupSort: r.getStringArg(args, "group_sort"),
                
                // Filtering
                Where: r.getStringSliceArg(args, "where"),
                
                // Query mode
                UseHTTP: r.getBoolArg(args, "use_http"),
        }

        // Handle highlighting options
        if highlightData, exists := args["highlight"]; exists </span><span class="cov8" title="1">{
                if highlightMap, ok := highlightData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        searchArgs.Highlight = &amp;search.HighlightOptions{
                                Enabled:         r.getBoolFromMap(highlightMap, "enabled"),
                                Fields:          r.getStringSliceFromMap(highlightMap, "fields"),
                                Limit:           r.getIntFromMap(highlightMap, "limit"),
                                LimitPerField:   r.getIntFromMap(highlightMap, "limit_per_field"),
                                LimitWords:      r.getIntFromMap(highlightMap, "limit_words"),
                                Around:          r.getIntFromMap(highlightMap, "around"),
                                StartTag:        r.getStringFromMap(highlightMap, "start_tag"),
                                EndTag:          r.getStringFromMap(highlightMap, "end_tag"),
                                NumberFragments: r.getIntFromMap(highlightMap, "number_of_fragments"),
                        }
                }</span>
        }

        // Handle fuzzy options
        <span class="cov8" title="1">if fuzzyData, exists := args["fuzzy"]; exists </span><span class="cov8" title="1">{
                if fuzzyMap, ok := fuzzyData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        searchArgs.Fuzzy = &amp;search.FuzzyOptions{
                                Enabled:  r.getBoolFromMap(fuzzyMap, "enabled"),
                                Distance: r.getIntFromMap(fuzzyMap, "distance"),
                                Preserve: r.getIntFromMap(fuzzyMap, "preserve"),
                                Layouts:  r.getStringSliceFromMap(fuzzyMap, "layouts"),
                        }
                }</span>
        }

        // Handle boolean query
        <span class="cov8" title="1">if boolQueryData, exists := args["bool_query"]; exists </span><span class="cov8" title="1">{
                if boolQueryMap, ok := boolQueryData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        boolQuery, err := r.mapToBoolQuery(boolQueryMap)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid bool_query: %w", err)
                        }</span>
                        <span class="cov8" title="1">searchArgs.BoolQuery = boolQuery</span>
                }
        }

        // Validation
        <span class="cov8" title="1">if searchArgs.Table == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("table parameter is required")
        }</span>

        <span class="cov8" title="1">return searchArgs, nil</span>
}

func (r *Registry) getBoolArg(args map[string]interface{}, key string) bool <span class="cov8" title="1">{
        if val, exists := args[key]; exists </span><span class="cov8" title="1">{
                if b, ok := val.(bool); ok </span><span class="cov8" title="1">{
                        return b
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (r *Registry) getStringSliceArg(args map[string]interface{}, key string) []string <span class="cov8" title="1">{
        if val, exists := args[key]; exists </span><span class="cov8" title="1">{
                if slice, ok := val.([]interface{}); ok </span><span class="cov8" title="1">{
                        result := make([]string, 0, len(slice))
                        for _, item := range slice </span><span class="cov8" title="1">{
                                if str, ok := item.(string); ok </span><span class="cov8" title="1">{
                                        result = append(result, str)
                                }</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }
                // Handle case where it's already []string
                <span class="cov8" title="1">if strSlice, ok := val.([]string); ok </span><span class="cov8" title="1">{
                        return strSlice
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (r *Registry) getStringIntMapArg(args map[string]interface{}, key string) map[string]int <span class="cov8" title="1">{
        if val, exists := args[key]; exists </span><span class="cov8" title="1">{
                if mapData, ok := val.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        result := make(map[string]int)
                        for k, v := range mapData </span><span class="cov8" title="1">{
                                switch value := v.(type) </span>{
                                case int:<span class="cov8" title="1">
                                        result[k] = value</span>
                                case float64:<span class="cov8" title="1">
                                        result[k] = int(value)</span>
                                }
                        }
                        <span class="cov8" title="1">return result</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// Helper methods for nested map access
func (r *Registry) getBoolFromMap(m map[string]interface{}, key string) bool <span class="cov8" title="1">{
        if val, exists := m[key]; exists </span><span class="cov8" title="1">{
                if b, ok := val.(bool); ok </span><span class="cov8" title="1">{
                        return b
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (r *Registry) getStringFromMap(m map[string]interface{}, key string) string <span class="cov8" title="1">{
        if val, exists := m[key]; exists </span><span class="cov8" title="1">{
                if str, ok := val.(string); ok </span><span class="cov8" title="1">{
                        return str
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

func (r *Registry) getIntFromMap(m map[string]interface{}, key string) int <span class="cov8" title="1">{
        if val, exists := m[key]; exists </span><span class="cov8" title="1">{
                switch v := val.(type) </span>{
                case int:<span class="cov8" title="1">
                        return v</span>
                case float64:<span class="cov8" title="1">
                        return int(v)</span>
                }
        }
        <span class="cov8" title="1">return 0</span>
}

func (r *Registry) getStringSliceFromMap(m map[string]interface{}, key string) []string <span class="cov8" title="1">{
        if val, exists := m[key]; exists </span><span class="cov8" title="1">{
                if slice, ok := val.([]interface{}); ok </span><span class="cov8" title="1">{
                        result := make([]string, 0, len(slice))
                        for _, item := range slice </span><span class="cov8" title="1">{
                                if str, ok := item.(string); ok </span><span class="cov8" title="1">{
                                        result = append(result, str)
                                }</span>
                        }
                        <span class="cov8" title="1">return result</span>
                }
                <span class="cov8" title="1">if strSlice, ok := val.([]string); ok </span><span class="cov8" title="1">{
                        return strSlice
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// mapToBoolQuery converts map to BoolQuery structure
func (r *Registry) mapToBoolQuery(boolMap map[string]interface{}) (*search.BoolQuery, error) <span class="cov8" title="1">{
        boolQuery := &amp;search.BoolQuery{}

        // Handle must clauses
        if mustData, exists := boolMap["must"]; exists </span><span class="cov8" title="1">{
                if mustSlice, ok := mustData.([]interface{}); ok </span><span class="cov8" title="1">{
                        clauses, err := r.mapToQueryClauses(mustSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid must clauses: %w", err)
                        }</span>
                        <span class="cov8" title="1">boolQuery.Must = clauses</span>
                }
        }

        // Handle should clauses
        <span class="cov8" title="1">if shouldData, exists := boolMap["should"]; exists </span><span class="cov8" title="1">{
                if shouldSlice, ok := shouldData.([]interface{}); ok </span><span class="cov8" title="1">{
                        clauses, err := r.mapToQueryClauses(shouldSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid should clauses: %w", err)
                        }</span>
                        <span class="cov8" title="1">boolQuery.Should = clauses</span>
                }
        }

        // Handle must_not clauses
        <span class="cov8" title="1">if mustNotData, exists := boolMap["must_not"]; exists </span><span class="cov8" title="1">{
                if mustNotSlice, ok := mustNotData.([]interface{}); ok </span><span class="cov8" title="1">{
                        clauses, err := r.mapToQueryClauses(mustNotSlice)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid must_not clauses: %w", err)
                        }</span>
                        <span class="cov8" title="1">boolQuery.MustNot = clauses</span>
                }
        }

        <span class="cov8" title="1">return boolQuery, nil</span>
}

// mapToQueryClauses converts slice of maps to QueryClause slice
func (r *Registry) mapToQueryClauses(clauseSlice []interface{}) ([]search.QueryClause, error) <span class="cov8" title="1">{
        clauses := make([]search.QueryClause, 0, len(clauseSlice))

        for _, clauseData := range clauseSlice </span><span class="cov8" title="1">{
                if clauseMap, ok := clauseData.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                        clause := search.QueryClause{}

                        // Get type
                        if typeVal, exists := clauseMap["type"]; exists </span><span class="cov8" title="1">{
                                if typeStr, ok := typeVal.(string); ok </span><span class="cov8" title="1">{
                                        clause.Type = typeStr
                                }</span>
                        }

                        // Get data
                        <span class="cov8" title="1">if dataVal, exists := clauseMap["data"]; exists </span><span class="cov8" title="1">{
                                clause.Data = dataVal
                        }</span>

                        <span class="cov8" title="1">clauses = append(clauses, clause)</span>
                }
        }

        <span class="cov8" title="1">return clauses, nil</span>
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
